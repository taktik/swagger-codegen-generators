{{>licenseInfo}}
{{#operations}}

import { XHR } from "./XHR"
{{#imports}}
import { {{classname}} } from '../{{filename}}';
{{/imports}}

{{#description}}
/**
 * {{&description}}
 */
{{/description}}

export class {{classname}} {
  host: string
  headers: Array<XHR.Header>
  fetchImpl?: (input: RequestInfo, init?: RequestInit) => Promise<Response>

  constructor(host: string, headers: any, fetchImpl?: (input: RequestInfo, init?: RequestInit) => Promise<Response>) {
    this.host = host
    this.headers = Object.keys(headers).map(k => new XHR.Header(k, headers[k]))
    this.fetchImpl = fetchImpl
  }

  setHeaders(h: Array<XHR.Header>) {
    this.headers = h
  }

  handleError(e: XHR.XHRError): never {
    throw e
  }

  {{#operation}}
  {{#contents}}

     /**
      * {{&notes}}
      {{#summary}}
      * @summary {{&summary}}
      {{/summary}}
      {{#allParams}}* @param {{paramName}} {{description}}
      {{/allParams}}*/
 {{operationId}}({{#allParams}}{{^isBodyParam}}{{paramName}}{{^required}}?{{/required}}: {{{dataType}}}{{#isFormParam}} | any[]{{/isFormParam}}{{#hasMore}}, {{/hasMore}}{{^hasMore}}{{#hasBodyParam}}, {{/hasBodyParam}}{{/hasMore}}{{/isBodyParam}}{{/allParams}}{{#bodyParams}}{{paramName}}?: {{{dataType}}}{{#hasMore}}, {{/hasMore}}{{/bodyParams}}): Promise<{{#returnType}}{{{returnType}}}{{/returnType}}{{^returnType}}any | Boolean{{/returnType}}> {
    let _body = null
    {{#bodyParam}}_body = {{paramName}}
    {{/bodyParam}}{{#formParams}}
    if ({{paramName}} && !_body) {
      const parts = Array.isArray({{paramName}}) ? {{paramName}} as any[] : [{{paramName}} as ArrayBuffer]
      const _blob = new Blob(parts, {type: "application/octet-stream"})
      _body = new FormData()
      _body.append("{{paramName}}", _blob)
    }
    {{/formParams}}

    const _url = this.host + `{{path}}` + "?ts=" + new Date().getTime() {{#queryParams}} + ({{paramName}} ? "&{{paramName}}=" + encodeURIComponent(String({{paramName}})) : ""){{/queryParams}}
    let headers = this.headers
    {{#consumes}}
    {{#mediaType}}headers = headers.filter(h => h.header !== "Content-Type").concat(new XHR.Header("Content-Type", "{{mediaType}}")){{/mediaType}}
    {{/consumes}}
    {{#headerParams}}
        {{paramName}} && (headers = headers.concat(new XHR.Header("{{baseName}}", {{paramName}})))
    {{/headerParams}}
    return XHR.sendCommand("{{httpMethod}}", _url, headers, _body, this.fetchImpl)
      .then(doc => {{#returnType}}
          {{#isBinary responseType}}doc.body{{else}}
              {{^isListContainer}}{{^returnTypeIsPrimitive}}new {{{returnType}}}(doc.body as JSON){{/returnTypeIsPrimitive}}{{#returnTypeIsPrimitive}}JSON.parse(JSON.stringify(doc.body)){{/returnTypeIsPrimitive}}
              {{/isListContainer}}{{#isListContainer}}(doc.body as Array<JSON>).map(it => {{^returnTypeIsPrimitive}}new {{{returnBaseType}}}{{/returnTypeIsPrimitive}}{{#returnTypeIsPrimitive}}JSON.parse(JSON.stringify{{/returnTypeIsPrimitive}}(it){{#returnTypeIsPrimitive}}){{/returnTypeIsPrimitive}}){{/isListContainer}}
          {{/isBinary}}
      {{/returnType}}
      {{^returnType}}(true){{/returnType}})
      .catch(err => this.handleError(err))
}
  {{/contents}}
  {{/operation}}
}
{{newline}}
{{/operations}}
